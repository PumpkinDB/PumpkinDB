// Copyright (c) 2017, All Contributors (see CONTRIBUTORS file)
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//! # PumpkinScript
//!
//! PumpkinScript is a minimalistic concatenative, stack-based language inspired
//! by Forth.
//!
//! It is used in PumpkinDB to operate a low-level database "virtual machine" —
//! to manipulate, record and retrieve data.
//!
//! This is an ultimate gateway to flexibility in how PumpkinDB can operate, what
//! formats can it support, etc.
//!
//! # Reasoning
//!
//! Why is it important?
//!
//! In previous incarnations (or, rather, inspirations) of PumpkinDB much more rigid structures,
//! formats and encoding were established as a prerequisite for using it, unnecessarily limiting
//! the applicability and appeal of the technology and ideas behind it. For example, one had to buy
//! into [ELF](https://rfc.eventsourcing.com/spec:1/ELF), UUID-based event identification and
//! [HLC-based](https://rfc.eventsourcing.com/spec:6/HLC) timestamps.
//!
//! So it was deemed to be important to lift this kind of restrictions in PumpkinDB. But how do we
//! support all the formats without knowing what they are?
//!
//! What if there was a way to describe how data should be processed, for example,
//! for indexing — in a compact, unambiguous and composable form? Or even for recording data
//! itself?
//! Well, that's where the idea to use something like a Forth-like script was born.
//!
//! Instead of devising custom protocols for talking to PumpkinDB, the protocol of communication has
//! become a pipeline to a script executor.
//!
//! So, for example, a command/events set can be recorded with something like this (not an actual
//! script, below is pseudocode):
//!
//! ```forth
//! <command id> <command payload> JOURNAL <event id> <event payload> JOURNAL
//! ```
//!
//! This offers us enormous extension and flexibility capabilities. To name a few:
//!
//! * Low-level imperative querying (as a foundation for declarative queries)
//! * Indexing filters
//! * Subscription filters
//!
//! # Features
//!
//! * Binary and text (human readable & writable) forms
//! * No types, just byte arrays
//! * Dynamic code evaluation
//! * Zero-copy interpretation (where feasible; currently does not apply to the most
//!   important part, the storage itself as transactional model of LMDB precludes us
//!   from carrying these references outside of the scope of the transaction)
//!
extern crate core;
#[macro_use] extern crate nom;
extern crate num_bigint;
extern crate num_traits;
extern crate byteorder;


#[macro_use]
pub mod macros;

pub mod binparser;
pub use self::binparser::parse as parse_bin;


pub mod textparser;
pub use self::textparser::parse;

mod packable;
pub use packable::{Packable, Unpackable};

pub mod encodables;

pub use self::encodables::{Encodable, Instruction, InstructionRef, Closure, Receivable};

use std::fmt;

#[inline]
pub fn offset_by_size(size: usize) -> usize {
    match size {
        0..=120 => 1,
        120..=255 => 2,
        255..=65535 => 3,
        65536..=4294967296 => 5,
        _ => unreachable!(),
    }
}

pub type Program = Vec<u8>;

/// Parse-related error
#[derive(Debug, PartialEq)]
pub enum ParseError {
    /// Incomplete input
    Incomplete,
    /// Error with a code
    Err(u32),
    /// Unknown error
    UnknownErr,
    /// Unparseable remainder
    Superfluous(Vec<u8>),
}

impl fmt::Display for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            &ParseError::Incomplete => {
                write!(f, "Incomplete input")
            },
            &ParseError::Err(u32) => {
                write!(f, "Error {}", u32)
            },
            &ParseError::Superfluous(ref v) => {
                write!(f, "Superfluous \"{}\"", String::from_utf8(v.clone()).unwrap().trim())
            },
            &ParseError::UnknownErr => {
                write!(f, "Unknown error")
            }
        }
    }
}

pub use nom::IResult as ParseResult;
